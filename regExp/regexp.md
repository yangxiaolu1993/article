## 正则表达式

> 记录在学习过程中的知识点

------

### 语法

#### 非打印字符

非打印字符可以理解为：在页面中肉眼看不到，但却存在的字符。比如：空格

|  字符   | 描述  | 记忆方式 |
|  ----  | ----  | ----  |
| \f  | 单元格 | 单元格 |
| 单元格  | 单元格 | 单元格 |

#### 匹配子表达式的数量

子表达式：正则表达式中任何一个字符都可以认为是子表达式，例如：表达式 ``` /do/g ```，d 和 o 都可以认为是此表达式的子表达式。当匹配的字符使用括号()包裹的时候，() 内的内容就是表达式的子表达式。

|  字符   | 描述  | 次数 | 记忆方式 |
|  ----  | ----  | ----  |----  |
| *  | 匹配前面的 子表达式 | 0 次、多次 | 用 * 时，就是所有的意思  |
| +  | 匹配前面的 子表达式 | 1 次、多次 | 代码编写中 x++ 代表的是 x+1 |
| ？ | 匹配前面的 子表达式 | 0 次、1 次 | js 中与 ？ 有关的就是条件运算符。非 true 及 false |
| {n}  | 匹配前面的 子表达式 | n 次 | 在 ES6 中，{} 代表着一个作用域，可以理解为在这个次数范围内  |
| {n,}  | 匹配前面的 子表达式 | 至少 n 次 | ----  |
| {n,m} | 匹配前面的 子表达式 | n-m 次 | ----  |

特殊说明  

正则表达式匹配的规则是：一个字符一个字符的匹配

1、* 和 + 是贪婪的，何为贪婪，就是他们会尽可能多的匹配字符串。
* \* 代表是 0次到多次，在一个字符串中，会尽可能多的匹配子表达式。如果能匹配2次就不匹配1次

```
let str = 'sdiavavb'
let reg1 = /(av)*/g
console.log(str.match(reg1)) // ['','','','avav','','']
```
说明：str.match(reg) 以数组的形式返回匹配的字符串。reg1 表达式的意思是匹配 av 子表达式0次或多次。字符串按照顺序匹配，由于 * 是包括匹配 0 次，所以 s 也是符合的，只是匹配的字符串为 空。当匹配到 av 时，由于 * 匹配是贪婪的，尽可能多的匹配，所以也会匹配第一个 av 之后的，第二个 av ，当成一个匹配的字符串。所以最终返回的是 ```['','','','avav','','']```

但是我们想要匹配的只是一个字符串 av 。所以就要解决 * 匹配的贪婪，？就有这个作用，实现非贪婪或最小匹配。

```
let str = 'sdiavavb'
let reg1 = /(av)*?/g
console.log(str.match(reg1)) // ['','','','','','','','']
```

既然是实现最小匹配，可以理解：* 匹配 0次就行，+ 匹配1次就行。

上面的表达式输出全部的空字符串也就不难理解了。但字符串按照顺序匹配的时候，每个字符都符合匹配 0 次，所以全部输入空字符串。

#### 特殊意义字符

|  字符   | 描述  | 记忆方式 |
|  ----  | ----  | ----  |
| $ | 前面的子表达式在匹配字符串的结尾的位置 | 单元格 |
| () | 标识一个子表达式的开始和结束 | 单元格 |
| [] | 标识一个表达式的开始和结束，表达式中是或的关系 | 单元格 |
| ^ | 匹配字符串开始的位置 | 单元格 |
| \| | 两项之间选择一个，可以理解为或 | 单元格 |

特殊说明

这里需要特殊说明的是 () 子表达式

1、使用 () 标识的子表达式有一个规则，就是相关匹配的字符串会被缓存起来。可以使用 $n 来代替匹配到的字符串，n 代表是第几个子表达式。通常用于字符串的替换，str.replace(reg,$1)

```
let str = 'sapdb0SAP00'
console.log(str.replace(/(sap)/gi,'$1++')) // sap++db0SAP++00

```

2、使用 () 标识的子表达式有一个副作用，就是没有用到字符串也会被缓存起来。
