

> 单页 Web 应用（single page web application，SPA），是当今网站开发技术的弄潮儿，仅靠加载单个 HTML 页面就在网站开发中占据了一席之地。很多传统网站正在或者已经转型为单页 Web 引用。单页 Web 应用网站也如雨后春笋般出现在大众眼前。前后端分离技术、MVVM 模式、前端路由、webpack 打包器也随之孕育而生。如果你是一名 Web 应用开发人员，却还没有发开或者甚至不了解单页 Web 应用，那就要加油了！  

为了配合单页 Web 应用快速发展的节奏，这几年，各类前端组件化技术栈层出不穷。通过不断的版本迭代 React、Vue 脱颖而出，成为当下很受欢迎的两大技术栈。

技术栈 |  发布   | NPM 下载量（2020.1.1~2020.7.31）| GitHub Star| 发展趋势 
---   |  :--:  | :--:    |   :--:     | :--:
React | 2011年 | 227,023,229 | 154 K | 持续增长
Vue   | 2014年 | 46,249,304  | 170 K | 持续增长

仅 7 个月的时间，两个技术栈的下载量就突破了百万，React 甚至突破了千万。可以想象这两个技术栈是多么受欢迎。

不管是现下流行的 React、Vue，还是红极一时的 Angular、Ember。只要是单页 Web 应用开发，都离不开前端路由的配合。如果我们把单页 Web 应用比作一间房，每个页面分别对应房子中的每个房间，那么路由就是每个房间的门，所以不管房间装饰的有多漂亮，没有门，也无法展示在用户眼前，路由在单页面 Web 应用开发的重要性也就不言而喻了。

OK，既然路由这么重要，那我们从这几个方面，来讲解前端路由吧。

![](https://img12.360buyimg.com/imagetools/jfs/t1/149777/13/5226/148749/5f31054dEcecc1fea/289a687a8a070dcc.png)

## 前端路由前世今生

### 后端路由

路由这个概念最先是在后端出现的，在 Web 开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。用户通过 URL 访问到的页面，大多都是通过后端路由匹配之后在返回给浏览器的。

![服务端渲染](https://img12.360buyimg.com/imagetools/jfs/t1/145816/20/5225/177101/5f325408Eb6b62cc1/09641c19f311ff92.png)

在前端路由出现之前，HTML，CSS，JavaScript 的文件以及数据载体 json(xml) 等文件，都是以模板的形式放到后端网站目录下的。在 Web 后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的 URL 地址，以及一些表单提交、ajax请求的地址。请求一个 URL 地址时，URL 地址进行后端路由匹配，将模板拼接好后将之返回给前端完整的 HTML，浏览器拿到这个 HTML 文件后直接解析展示了。


### 过渡

以后端路由为基础，开发的 Web 应用，都会存在一个弊端。每跳转到不同的 URL，都是重新访问服务端，服务器拼接形成完整的 HTML，返回到浏览器。浏览器的前进、后退键都会重新访问服务器，没有合理地利用缓存。 

随着前端页面复杂性越来越高，功能越来越完善，后端网站目录下的代码文件会越来越多，耦合性也越来越严重。就算简单的颜色修改，也需要前后端的同步操作。由于以 JavaScript 为代表的前端技术尚未崛起，程序猿没办法实现前端渲染。

直到 1998 年，微软的 Outloook Web App 团队提出 Ajax 的基本概念（XMLHttpRequest 的前身），2005 年 Google Map 的发布让 Ajax 这项技术发扬光大，向人们展示了它真正的魅力，前后端分离的开发模式开始兴起。2008 年，Google V8 引擎发布，JavaScript 随之崛起，前端工程师开始借鉴后端模板思想，单页面应用就此诞生。

于是，我们开始进入了前端路由的时代。

## 前端路由

单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现这一功能，前端路由问世了。页面跳转的 URL 规则匹配由前端来控制。

![客户端渲染](https://img11.360buyimg.com/imagetools/jfs/t1/122174/23/9461/155946/5f325431Ed7c3ac00/131fbced1f4ffe8c.png)

前端路由的兴起，使得页面渲染由服务器渲染变成了前端渲染。为什么这么说呢！请求一个 URL 地址时，服务器不需要拼接模板，只需返回一个HTML即可，一般浏览器拿到的 html 是这样的：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Demo</title>
  <link href="app.css" rel="stylesheet"/>
</head>
<body>
  <div id="app"></div>
  <script type="text/javascript" src="app.js"></script>
</body>
</html>

```
这里空荡荡的只有一个```<div id="app"></div>```，以及一系列的js文件，所以说这个html是不完整的。我们看到的页面是通过这一系列的js渲染出来的，也就是我们常说的前端渲染。前端渲染通过客户端的算力来解决页面的构建，很大程度上缓解了服务端的压力。加上前端路由的配合，实现了无缝页面切换体验的用户体验。

## 原理解析

前面说到了啰嗦了这么多，大家可能要问，路由到底是个啥？为什么它能让用户体验无缝页面切换效果？URL变化，为什么不用去重新访问？其实，前端路由的实现原理很简单，现在就跟着小编一起来揭开它神秘的面纱吧！

前端路由有两种实现方式：

* hash 值 + onhashchange 事件
* history 对象 + pushState() 方法 + onpopstate 事件

### hash 路由

hash 路由，也称为哈希路由。类似 https://xiaobian.com/#/home 就是哈希路由。hash 指的是 URL 地址中的锚部分，也就是 # 后面的部分，利用 URL 中的 hash 值的变化就可以实现页面的跳转。改变 hash 值的方式有3种：

1. 页面按钮点击跳转
2. 浏览器前进、后退键
3. 手动刷新当前的 URL（点击 Enter 键进行刷新）

前两种改变 hash 值的方式，并不会导致浏览器向服务器发送请求，浏览器不发出请求，也就不会刷新页面。hash 值改变，会触发全局 window 对象上的 hashchange 事件，通过 hashchange 事件来监听到 URL 的变化，从而进行 DOM 操作来模拟页面跳转。  

手动刷新 URL，与在浏览器中输入 URL，Enter 回车的情况是一样的，浏览器会重新向服务器发送请求，服务器返回 index.html，不会触发 hashchange 事件，但是会触发 load 事件。

![hash 流程图](https://img13.360buyimg.com/imagetools/jfs/t1/119923/18/9500/67035/5f335933Ee392a6e3/cf3e580523d52c0a.png)  

原理是不是很简单，既然这么简单，我们何不动手尝试一下呢？

#### 原生 JS 实现 hash 路由

首先了解：如何自定义一个vue插件？vue.install()   vue.use()
1. router-link 与 router-view 组件
2. a 标签实现跳转
3. router-link 初始化为 a 标签
4. 自定义组件，使用render方式
5. 每一个 vue 组件都是一个 vue 实例，只是根实例会有一些不一样的属性，比如$el
6. 父组件与子组件加载时的生命周期的加载顺序
7. vue.mixins 全局混入，一旦使用全局混入，将影响之后每一个创建的vue实例
8. vue.mixins 会在当前 vue 实例之前执行