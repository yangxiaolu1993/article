
### TCP/IP协议族按层次分为：（协议可以理解成规则）
* 应用层（FPT、DNS、HTTP）  
决定的是用户提供应用服务时的活动。比如：FPT（文件传输协议）、DNS（域名解析协议）、万维网（WWW）访问HTTP协议、发送电子邮件（SMTP）


* 传输层（TCP、UDP）
对应上层的应用层，提供处于网络链接中的两台计算机之间的数据传输。
在传输层有两个性质完全不同的协议：TCP（传输控制协议）、UDP（用户数据报协议）

* 网络层
负责提供基本的数据封包传送功能，让每一块数据包都能达到目的主机。IP协议

* 数据链路层
用来处理连接网络的硬件部分。控制操作系统、硬件的设备驱动、NIC（网络适配器，即网卡）

**为什么TCP建立连接需要三次握手？**

* 防止出现失效的连接请求报文段被服务端接受的情况，从而产生错误。
* 每台服务器可供支撑的TCP连接数量是有限制的。

#### UDP与TCP区别：

UDP相比TCP简单的多，不需要建立连接，不需要验证数据报文，不需要流量控制，只会把想发的数据报文一股脑的丢给对端
虽然UDP并没有TCP传输来的准确，但是也能在很多实时性要求高德地方有所作为

Http2中最基本的协议单位是帧。每个帧都有不同的类型和用途。报头和数据帧组成了基本的http请求和响应

HTTP2性能提升的核心是二进制分帧层。（解决HTTP1.x中存在的队首阻塞问题）
把HTTP消息分解为独立的帧，交错发送，然后在另一端重新组装是HTTP2.0最重要的一项增强。

#### HTTP与HTTP2的区别：

* HTTP1.0需要开启多个连接来实现并发
* HTTP1.0没有对头部进行压缩（当请求一个页面的时候，可能会有上百个请求，这些请求拥有相同的头部），造成不必要的阻塞，HTTP2.0通过二进制分帧层解决。
* HTTP1.0没有应用资源优先级

**带宽：频率范围的大小**

#### 跨域请求


现在大部分的浏览器都是使用的cors跨域请求，但是IE10以下（不包含IE10）的浏览器是不支持cors跨域请求的

产生跨域的原因：浏览器的同源策略---协议、域名、端口均相同。需要注意的是：就算域名和IP指向同一地址，也属于跨域。同源策略只存在于浏览器中，不存在与服务器中。

同源策略的出发点很简单，浏览器存储着用户数据，比如认证令牌、cookie及其他私有元素，这些数据不能泄露给其他应用。如果没有同源沙箱，那么example.com中的脚本就可以访问并操作thirdparty.com的用户数据


##### CORS跨域请求

后台设置就行，前端不用
设置接口的响应头，服务器设置HTTP响应头中Access-Control-Allow-Origin值，解除跨域限制



##### HTTP请求

**响应首部声明**
Connection:Keep-Alive    保持HTTP持久化连接，减少TCP的三次握手时间，当TCP建立连接以后，第二次请求的TCP连接就会减少一次往返时间


HTTP1.X不支持多路复用，支持每个主机打开6个连接

**Http请求头中的referer**

将http请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发送的referer不符合他的要求，就会拦截或者跳转到他要求的地址，然后在通过这个地址进行访问。


#### 代理

**正向代理**：位于客户端与原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求，然后代理向原始服务器转发请求并将得到的内容返回给客户端。

**简单来说**：A向C借钱，由于一些原因A不能直接向C借钱，于是A让B向C借钱，但是C并不知道A的存在

**反向代理**：以代理服务器来接受客户端发送的Internet请求，将请求转发到内部网络上的服务，并将从服务器得到的结果返回给客户端发送的请求

**简单来说**：A向B借钱，B没钱，向C借钱，然后在借给A，但是A并不知道C的存在


#### DNS、TCP请求、HTTP请求 前端优化

DNS优化：减少DNS的请求次数、进行DNS预处理（Prefetching）。CDN域名主要指的是存到静态资源的域名。
TCP请求：减少TCP的请求数，也就是减少HTTP的请求数量。主要指的是TCP的握手次数和释放次数。
HTTP请求：就是在开发过程中的数据获取方式。







### SSR 服务器渲染

CSR 客户端渲染，是指用 JS 直接在浏览器里渲染页面，包括数据请求、视图模板、路由在内的所有逻辑都是客户端处理。

SSR （Server-Side Rendering）即服务端渲染，就是将页面在服务端渲染完成后再客户端直接展示。之前就存在SSR渲染，前后端分离后，更新了SSR渲染。

传统的SPA模式：客户端渲染模式


SSR 原理

vuejs 官方的SSR原理介绍图，可以知道：通过 webpack 打包生成两份 bundle 文件

client bundle ，给浏览器用。和纯 vue前端项目 bundle 类似
server bundle，供服务端 SSR 使用 ，一个json文件

vue-server-renderer 库

Nuxt.js

Nuxt.js 是一个机遇 vue.js de 通用应用框架，一个用于 vue.js 开发 SSR 应用的一站式解决方案。它的优点是将原来几个配置文件要完成的内容，都整合在了一个 nuxt.config.js，封装与扩展性完美的契合。

简单说 nuxt.js 项目，其实就是一个 vue 的项目融合一个 node.js server 项目，这里的node服务有2个作用：
1、代替浏览器工作， 笼统理解 在 created 时的请求数据和页面渲染
2、当做静态文件服务器，把渲染好的页面返回给用户。

与传统SPA单页面应用相比，服务器渲染 SSR 有哪些优势：

1、更好的 SEO 即搜索引擎。传统的 SPA 单页面应用通过爬虫获取到的html中仅仅是一个 div 标签和一个打包好的 bundle.js ，不利于搜索引擎的网站收录
2、更快的内容到达时间，即首屏加载更快

服务器渲染应用场景：

1、有 SEO 需求
2、需要首屏加载速度贼快

